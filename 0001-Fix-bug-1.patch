From 713799bbc2864217298baecb21ede2965b1ec0a5 Mon Sep 17 00:00:00 2001
From: Marko Paunovic <fotongrafija@gmail.com>
Date: Sun, 26 Jan 2025 19:48:38 +0100
Subject: [PATCH] Fix bug #1

---
 src/hooks/useCharacterData.test.ts | 306 ++++++++++++++---------------
 src/hooks/useCharacterData.ts      |   9 +-
 2 files changed, 155 insertions(+), 160 deletions(-)

diff --git a/src/hooks/useCharacterData.test.ts b/src/hooks/useCharacterData.test.ts
index c866221..b179352 100644
--- a/src/hooks/useCharacterData.test.ts
+++ b/src/hooks/useCharacterData.test.ts
@@ -8,157 +8,157 @@ jest.mock('../utils/getApiUrl');
 jest.mock('./useCharacterFilter');
 
 describe('useCharacterData', () => {
-  // Common mocks
-  const mockGetApiUrl = getApiUrl as jest.Mock;
-  const mockUseCharacterFilter = useCharacterFilter as jest.Mock;
-
-  let originalFetch: typeof global.fetch;
-
-
-  beforeAll(() => {
-  // Set up a default mock fetch
-    global.fetch = jest.fn();
-  
-  });
-  beforeEach(() => {
-    originalFetch = global.fetch;
-
-    // Reset and restore all mocks
-    jest.clearAllMocks();
-    jest.restoreAllMocks();
-
-    // Provide a default environment variable
-    process.env.VITE_API_URL = 'http://gateway.marvel.com/';
-
-    
-  });
-
-  afterEach(() => {
-    // Restore original fetch
-    global.fetch = originalFetch;
-  });
-
-  it('should fetch data and update state when fetchCharacterData is called', async () => {
-    // Arrange
-    // Mock the return value of getApiUrl
-    mockGetApiUrl.mockReturnValue('https://mock-url.com/')
-    
-    // Mock useCharacterFilter to provide offsetPage
-    mockUseCharacterFilter.mockReturnValue({
-      offsetPage: 0,
-      setCustomFilter: jest.fn(),
-    })
-
-    // Mock global fetch
-    global.fetch = jest.fn().mockResolvedValue({
-      json: async () => ({
-        data: {
-          results: [{ id: 100, name: 'Mock Character' }],
-          total: 50,
-          limit: 20,
-          offset: 0
-        },
-      }),
-    } as Response)
-
-    // Act
-    // Render the hook
-    const { result } = renderHook(() => useCharacterData())
-
-    // Initially, loading is false
-    expect(result.current.loading).toBe(false)
-
-    // Call fetchCharacterData
-    await act(async () => {
-      await result.current.fetchCharacterData('Spider-Man')
-    })
-
-    // Assert
-    // 1) getApiUrl should be called with the correct args
-    expect(mockGetApiUrl).toHaveBeenCalledWith({
-      characterName: 'Spider-Man',
-      offsetParam: 0,
-    })
-
-    // 2) fetch was called
-    expect(global.fetch).toHaveBeenCalledWith('https://mock-url.com/')
-
-    // 3) loading should be false after fetch completes
-    expect(result.current.loading).toBe(false)
-
-    // 4) characterData should be populated
-    expect(result.current.characterData).toEqual({
-      results: [{ id: 100, name: 'Mock Character' }],
-      total: 50,
-      limit: 20,
-      offset: 0
-    })
-  })
-
-  it('should do nothing if characterName is empty', async () => {
-    mockGetApiUrl.mockReturnValue('https://mock-url.com/')
-    mockUseCharacterFilter.mockReturnValue({
-      offsetPage: 10,
-      setCustomFilter: jest.fn(),
-    })
-
-    global.fetch = jest.fn() // mock, but we want to check if it’s NOT called
-
-    const { result } = renderHook(() => useCharacterData())
-
-    // Call fetch with empty string
-    await act(async () => {
-      await result.current.fetchCharacterData('')
-    })
-
-    // Should NOT call fetch
-    expect(global.fetch).not.toHaveBeenCalled()
-    // characterData should remain undefined
-    expect(result.current.characterData).toBeUndefined()
-    // loading should be false
-    expect(result.current.loading).toBe(false)
-  })
-
-  it('should set error if fetch throws', async () => {
-    mockGetApiUrl.mockReturnValue('https://mock-url.com/')
-    mockUseCharacterFilter.mockReturnValue({
-      offsetPage: 0,
-      setCustomFilter: jest.fn(),
-    })
-
-    // Simulate a network or server error
-    global.fetch = jest.fn().mockRejectedValue(new Error('Network Error'));
-
-    const { result } = renderHook(() => useCharacterData())
-
-    await expect(result.current.fetchCharacterData('BadCharacter'))
-      .rejects.toThrow('Network Error');
-
-    // loading should be false
-    expect(result.current.loading).toBe(false)
-  })
-
-  it('should throw if VITE_API_URL is not defined (if your hook explicitly checks for it)', async () => {
-    // If your hook code throws an error when VITE_API_URL is undefined,
-    // let's remove it from the environment:
-    delete process.env.VITE_API_URL
-
-    
-    mockGetApiUrl.mockImplementation(() => {
-      throw new Error('Error fetching data')
-    })
-
-    mockUseCharacterFilter.mockReturnValue({
-      offsetPage: 0,
-      setCustomFilter: jest.fn(),
-    })
-
-    const { result } = renderHook(() => useCharacterData())
-
-    await expect(
-      act(async () => {
-        await result.current.fetchCharacterData('Spider-Man')
-      })
-    ).rejects.toThrow('Error fetching data')
-  })
+	// Common mocks
+	const mockGetApiUrl = getApiUrl as jest.Mock;
+	const mockUseCharacterFilter = useCharacterFilter as jest.Mock;
+
+	let originalFetch: typeof global.fetch;
+
+
+	beforeAll(() => {
+		// Set up a default mock fetch
+		global.fetch = jest.fn();
+
+	});
+	beforeEach(() => {
+		originalFetch = global.fetch;
+
+		// Reset and restore all mocks
+		jest.clearAllMocks();
+		jest.restoreAllMocks();
+
+		// Provide a default environment variable
+		process.env.VITE_API_URL = 'http://gateway.marvel.com/';
+
+
+	});
+
+	afterEach(() => {
+		// Restore original fetch
+		global.fetch = originalFetch;
+	});
+
+	it('should fetch data and update state when fetchCharacterData is called', async () => {
+		// Arrange
+		// Mock the return value of getApiUrl
+		mockGetApiUrl.mockReturnValue('https://mock-url.com/')
+
+		// Mock useCharacterFilter to provide offsetPage
+		mockUseCharacterFilter.mockReturnValue({
+			offsetPage: 0,
+			setCustomFilter: jest.fn(),
+		})
+
+		// Mock global fetch
+		global.fetch = jest.fn().mockResolvedValue({
+			json: async () => ({
+				data: {
+					results: [{ id: 100, name: 'Mock Character' }],
+					total: 50,
+					limit: 20,
+					offset: 0
+				},
+			}),
+		} as Response)
+
+		// Act
+		// Render the hook
+		const { result } = renderHook(() => useCharacterData())
+
+		// Initially, loading is false
+		expect(result.current.loading).toBe(false)
+
+		// Call fetchCharacterData
+		await act(async () => {
+			await result.current.fetchCharacterData('Spider-Man')
+		})
+
+		// Assert
+		// 1) getApiUrl should be called with the correct args
+		expect(mockGetApiUrl).toHaveBeenCalledWith({
+			characterName: 'Spider-Man',
+			offsetParam: 0,
+		})
+
+		// 2) fetch was called
+		expect(global.fetch).toHaveBeenCalledWith('https://mock-url.com/')
+
+		// 3) loading should be false after fetch completes
+		expect(result.current.loading).toBe(false)
+
+		// 4) characterData should be populated
+		expect(result.current.characterData).toEqual({
+			results: [{ id: 100, name: 'Mock Character' }],
+			total: 50,
+			limit: 20,
+			offset: 0
+		})
+	})
+
+	it('should do nothing if characterName is empty', async () => {
+		mockGetApiUrl.mockReturnValue('https://mock-url.com/')
+		mockUseCharacterFilter.mockReturnValue({
+			offsetPage: 10,
+			setCustomFilter: jest.fn(),
+		})
+
+		global.fetch = jest.fn() // mock, but we want to check if it’s NOT called
+
+		const { result } = renderHook(() => useCharacterData())
+
+		// Call fetch with empty string
+		await act(async () => {
+			await result.current.fetchCharacterData('')
+		})
+
+		// Should NOT call fetch
+		expect(global.fetch).not.toHaveBeenCalled()
+		// characterData should remain undefined
+		expect(result.current.characterData).toBeUndefined()
+		// loading should be false
+		expect(result.current.loading).toBe(false)
+	})
+
+	it('should set error if fetch throws', async () => {
+		mockGetApiUrl.mockReturnValue('https://mock-url.com/')
+		mockUseCharacterFilter.mockReturnValue({
+			offsetPage: 0,
+			setCustomFilter: jest.fn(),
+		})
+
+		// Simulate a network or server error
+		global.fetch = jest.fn().mockRejectedValue(new Error('Network Error'));
+
+		const { result } = renderHook(() => useCharacterData())
+
+		await expect(result.current.fetchCharacterData('BadCharacter'))
+			.rejects.toThrow('Network Error');
+
+		// loading should be false
+		expect(result.current.loading).toBe(false)
+	})
+
+	it('should throw if VITE_API_URL is not defined (if your hook explicitly checks for it)', async () => {
+		// If your hook code throws an error when VITE_API_URL is undefined,
+		// let's remove it from the environment:
+		delete process.env.VITE_API_URL
+
+
+		mockGetApiUrl.mockImplementation(() => {
+			throw new Error('Error fetching data')
+		})
+
+		mockUseCharacterFilter.mockReturnValue({
+			offsetPage: 0,
+			setCustomFilter: jest.fn(),
+		})
+
+		const { result } = renderHook(() => useCharacterData())
+
+		await expect(
+			act(async () => {
+				await result.current.fetchCharacterData('Spider-Man')
+			})
+		).rejects.toThrow('Error fetching data')
+	})
 })
\ No newline at end of file
diff --git a/src/hooks/useCharacterData.ts b/src/hooks/useCharacterData.ts
index a4a9a26..c2918db 100644
--- a/src/hooks/useCharacterData.ts
+++ b/src/hooks/useCharacterData.ts
@@ -59,22 +59,18 @@ export const useCharacterData = () => {
                 return data
             }
 
-            // setCharacterData(undefined)
             let payload = await fetchData()
-            console.log('fetching')
-            console.log('payload total', payload.data.total)
-            // console.log('first payload', payload.data)
            
             if (payload.data.total === 0) {
                 throw new Error("No data found")
             }
             if (!payload.data.results.length && payload.data.total > 0) {
                 
-                console.log('fetching again')
                 // clear payload
                 setCharacterData(undefined)
+                // second payload
                 payload = await fetchData()
-                console.log('second payload', payload.data)
+                
                 const total = payload.data.total
                 const limit = payload.data.limit
                 // If the offsetParam is greater than the total number of pages, set the offset to the last page
@@ -86,7 +82,6 @@ export const useCharacterData = () => {
             }
             setTotalPages(Math.ceil(payload.data.total / payload.data.limit))
             setCharacterData(payload.data as Response)
-            console.log('payload', payload.data)
         }
         catch (event) {
             setError(event as Error)
-- 
2.47.1.windows.2

